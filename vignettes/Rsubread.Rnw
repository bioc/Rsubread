%\VignetteIndexEntry{Rsubread Vignette}
%\VignetteDepends{}
%\VignetteKeywords{Read mapping}
%\VignettePackage{Rsubread}
\documentclass[12pt]{article}

\usepackage{hyperref}

\newcommand{\R}[1]{{\texttt{#1}}}
\newcommand{\C}[1]{{\texttt{#1}}}

\textwidth=6.2in
\textheight=8.5in
\oddsidemargin=0.2in
\evensidemargin=0.2in
\headheight=0in
\headsep=0in

\begin{document}
\title{Rsubread package: high-performance read alignment, quantification and mutation discovery}
\author{Wei Shi}
\date{15 November 2013}
\maketitle

\section{Introduction}
This vignette provides a brief description to the Rsubread package.
For more details, please refer to the Users Guide which can brought up in your R session via the following commands: \\

\noindent\R{> library(Rsubread)}\\
\R{> RsubreadUsersGuide()}\\

The Rsubread package provides facilities for processing the read data generated by next-gen sequencing technologies.
These facilities include quality assessment, read alignment, read summarization, exon-exon junction detection, absolute expression calling and SNP discovery.
They can be used to analyze data generated from all major sequencing platforms including Illumina GA/HiSeq, Roche 454, ABI SOLiD and Ion Torrent.

The Subread aligner (\R{align} function) is a highly efficient and accurate aligner for mapping genomic DNA and RNA sequencing reads.
It adopts a novel mapping paradigm called ``seed-and-vote".
Under this paradigm, a number of 16mers (called seeds or subreads) are extracted from each read and they were mapped to the reference genome to vote for the mapping location of the read.
Read mapping performed under this paradigm has been found to be more efficient and accurate than that carried out under the conventional ``seed-and-extend" paradigm (Liao et al. 2013).
This package also includes a program for detecting exon-exon junctions, \R{subjunc}, that makes use of the powerful ``seed-and-vote" paradigm too.

An important step in processing next-gen sequencing data is to assign mapped reads to genomic features such as genes, exons, and promoters.
This package includes a general-purpose read summarization function \R{featureCounts} that takes mapped reads as input and assigns them to genomic features.
In-built annotations are provided for users convenience.

Different from microarray technologies, the next-gen sequencing technologies do not provide Present/Absent calls for genomic features such as genes.
We have developed an algorithm to use the background noise measured from the RNA-seq data to call absolutely expressed genes.
The function \R{detectionCall} returns a detection p value for each gene from the read mapping results.

We have also developed a new SNP calling algorithm which is being implemented in function \R{exactSNPs}.
Our results showed that it compared favorably to competing methods, but was an order of magnitude faster.

This package also includes some other useful functions such as quality assessment (\R{qualityScores}, \R{atgcContent}), duplicate read removal (\R{removeDupReads}) and mapping percentage calculation (\R{propmapped}).

\section{Read alignment}
An index needs to be built first and then alignments can be carried out.
Building the index is an one-off operation.
The generated index can be re-used in subsequent read alignments.\\

{\noindent\bf Step 1: Index building \\}

The Rsubread package includes a dummy reference sequence that was created using 900 100bp reads generated from the SEquencing Quality Control (SEQC)  project, the third stage of MicroArray Quality Control (MAQC) project.
We take 1,000 100bp reads from a human brain reference RNA-seq dataset generated by the SEQC project and use 900 of them to build a reference sequence.
We then try to map the 1,000 reads to this reference sequence.
The reference sequence was generated by simply concatenating the sequences of randomly selected 900 reads.
After this sequence was generated, we can then build an index for it.
Below shows the command for the index building:

\begin{scriptsize}
<<>>=
library(Rsubread)
ref <- system.file("extdata","reference.fa",package="Rsubread")
path <- system.file("extdata",package="Rsubread")
buildindex(basename=file.path(path,"reference_index"),reference=ref)
@
\end{scriptsize}

The created index files are saved to the "extdata" folder in the directory where Rsubread package was installed.
Rsubread creates a hash table for indexing the reference genome. 
Keys in the hash table are the 16bp sequences and hash values are their corresponding chromosomal locations. 
Color space index can be built by setting the \R{colorsapce} argument to \R{TRUE}.\\

A unique feature of Rsubread is that it allows users to control the computer memory usage in the read mapping process.
Users can do this by specifying the amount of memory (in MB) to be used for mapping.
By default, 3700MB of memory will be used.
This will for example partition the index into two chunks for the human genome.
Only one chunk of index will be existent in the memory at any time.
To load the entire index into the memory, users can specify the requested amount of memory to be 8000MB for the human genome (
the actual memory usage is up to 7.6GB).
With this setting, Subread has the highest mapping speed.\\

{\noindent\bf Step 2: read mapping\\}

After the index was successfully built, we can now map the 1,000 reads to the reference sequence:

\begin{scriptsize}
<<>>=
reads <- system.file("extdata","reads.txt",package="Rsubread")
align(index=file.path(path,"reference_index"),readfile1=reads,
tieBreakHamming=TRUE,unique=TRUE,
output_file=file.path(path,"alignResults.SAM"))
@
\end{scriptsize}

Map paired-end reads:

\begin{scriptsize}
<<>>=
reads1 <- system.file("extdata","reads1.txt",package="Rsubread")
reads2 <- system.file("extdata","reads2.txt",package="Rsubread")
align(index=file.path(path,"reference_index"),readfile1=reads1,
readfile2=reads2,tieBreakHamming=TRUE,unique=TRUE,
output_file=file.path(path,"alignResultsPE.SAM"))
@
\end{scriptsize}

\section{Counting mapped reads for genomic features}

The \R{featureCounts} function is a general-purpose read summarization function, which assigns to the genomic features the mapped reads that were generated from genomic DNA and RNA sequencing.

This function takes as input a set of files containing read mapping results and assigns mapped reads in each file to genomic features. 
The input files can be in SAM or BAM format.
It can be used to assign reads to genes, exons or any features users defined.
This function includes in-built NCBI RefSeq gene annotations for genomes mm9, mm10 and hg19.

Below gives the example code of assigning to two genes the reads and fragments generated in the last section.
Assign reads to genes:

\begin{scriptsize}
<<>>=
ann <- data.frame(
GeneID=c("gene1","gene1","gene2","gene2"),
Chr="chr_dummy",
Start=c(100,1000,3000,5000),
End=c(500,1800,4000,5500),
Strand=c("+","+","-","-"),
stringsAsFactors=FALSE)
ann
file_SE <- file.path(path,"alignResults.SAM")
fc_SE <- featureCounts(file_SE,annot.ext=ann)
fc_SE
@
\end{scriptsize}

Assign fragments (read pairs) to genes:

\begin{scriptsize}
<<>>=
file_PE <- file.path(path,"alignResultsPE.SAM")
fc_PE <- featureCounts(file_PE,annot.ext=ann,isPairedEnd=TRUE)
fc_PE
@
\end{scriptsize}


\section{Finding exon junctions}

The RNA-seq technology provides a unique opportunity to identify the alternative splicing events that occur during the gene transcription process.
The \R{subjunc} function can be used to detect exon-exon junctions.
It first extracts a number of subreads (16mers) from each read, maps them to the reference genome and identifies the two best mapping locations for each read (representing potential locations of exons spanned by the read).
Then, it builds a junction table including all putative junctions.
Finally, it carries out a verification step to remove false positives in junction detection by realigning all the reads. 
The donor (`GT') and receptor sites(`AG'), are required to be present when calling exon-exon junctions. 
Output of this function includes the discovered exon-exon junctions and also read mapping results.

\section{Base quality scores}

Quality scores give the probabilities of read bases being incorrectly called, which is useful for examining the quality of sequencing data.
The \R{qualityScores} function can be used to quickly retrieve the quality score data from a read file.

\begin{scriptsize}
<<>>=
library(Rsubread)
reads <- system.file("extdata","reads.txt",package="Rsubread")
x <- qualityScores(filename=reads,nreads=1000)
boxplot(x)
@
\end{scriptsize}

\section{GC content}

The \R{atgcContent} function returns the fraction of each nucleotide type in the reads at each base location.

\begin{scriptsize}
<<>>=
library(Rsubread)
reads <- system.file("extdata","reads.txt",package="Rsubread")
## Fraction of A,T,G and C in the entire dataset
x <- atgcContent(filename=reads,basewise=FALSE)
## Fraction of A,T,G and C at each base location across all the reads
xb <- atgcContent(filename=reads,basewise=TRUE)
@
\end{scriptsize}

\section{Mapping percentage}

Function \R{propmapped} returns the proportion of mapped reads include in a SAM/BAM file.

\begin{scriptsize}
<<>>=
library(Rsubread)
results <- system.file("extdata","alignResults.SAM",package="Rsubread")
propmapped(results)
@
\end{scriptsize}

\section{Citation}
Yang Liao, Gordon K Smyth and Wei Shi (2013). The Subread aligner: fast, accurate and scalable read mapping by seed-and-vote. Nucleic Acids Research, 41(10):e108.\\

\noindent{Yang Liao, Gordon K Smyth and Wei Shi (2013). featureCounts: an efficient general-purpose read summarization program. Bioinformatics, In Press, accepted Nov 7.}

\section{Authors}
Wei Shi and Yang Liao \\
Bioinformatics Division \\
The Walter and Eliza Hall Institute of Medical Research \\
1G Royal Parade, Parkville, Victoria 3052 \\
Australia \\

\section{Contact}
Please contact Wei Shi (shi at wehi dot edu dot au) if you have any inquires.

\end{document}
